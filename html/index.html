<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Block-chain framework: Block-chain Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block-chain framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Block-chain <a class="el" href="classFramework.html">Framework</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Table of content</h2>
<ol type="1">
<li><a href="#section_overview">Overview</a></li>
<li><a href="#section_installation">Installation</a></li>
<li><a href="#section_create">How to create a new block-chain</a><ol type="a">
<li><a href="#section_node">Node</a></li>
<li><a href="#section_config">Config</a></li>
<li><a href="#section_transaction">Transaction</a><ol type="i">
<li><a href="#sub_section_useful">Useful methods</a></li>
<li><a href="#sub_section_serialization">Serialization methods</a></li>
<li><a href="#sub_section_ui">UI methods</a></li>
<li><a href="#sub_section_database">Database methods</a></li>
</ol>
</li>
<li><a href="#section_reward">Reward</a></li>
<li><a href="#section_serializer">Serializer</a></li>
<li><a href="#section_proof">Proof</a><ol type="i">
<li><a href="#sub_section_newproof">New proof</a></li>
<li><a href="#sub_section_feedframework">Feed the framework</a></li>
<li><a href="#sub_section_newmetadata">New metadata</a></li>
</ol>
</li>
<li><a href="#section_hash">Hash</a><ol type="i">
<li><a href="#sub_section_newhash">New hash</a></li>
<li><a href="#sub_section_feedframeworkhash">Feed the framework</a></li>
</ol>
</li>
<li><a href="#section_database">Database</a></li>
</ol>
</li>
<li><a href="#section_helpers">Helpers</a><ol type="a">
<li><a href="#section_transactionManager">TransactionManager</a></li>
<li><a href="#section_framework">Framework</a></li>
</ol>
</li>
<li><a href="#section_todo">TODO-List</a><ol type="a">
<li><a href="#sub_section_cryptography">Cryptography</a></li>
<li><a href="#sub_section_proof">Proof</a></li>
<li><a href="#sub_section_header">Header files</a></li>
</ol>
</li>
</ol>
<h2>Overview <a class="anchor" id="section_overview"></a></h2>
<p class="">This project is a C++ <a class="el" href="classFramework.html">Framework</a> built to allow easy and fast development of any kind of block-chain. <br />
 The idea is to limit the development to transactions and data representation only. No need to implement anything else. <br />
 Of course, as a framework, it provides a big flexibility, therefore, it is possible to write advanced block-chain by configuring as many things as you want. <br />
 </p><blockquote class="doxtable">
<p class="">Note that everything can change to allow more flexibility. </p>
</blockquote>
<h2>Installation <a class="anchor" id="section_installation"></a></h2>
<p class="">To install the framework, you just have to copy/paste the folder <code>block_chain</code> in your project's root folder</p>
<h2>How to create a new block-chain <a class="anchor" id="section_create"></a></h2>
<p class="">To create your own block-chain program, you just have to run the main objects provided by the framework. </p><h3><a class="el" href="classNode.html">Node</a> <a class="anchor" id="section_node"></a></h3>
<p class="">The node is the peer itself. You only have to create it and it will run. </p><div class="fragment"><div class="line"><a class="code" href="classNode.html">Node</a> node(config);</div></div><!-- fragment --> <h3><a class="el" href="classConfig.html">Config</a> <a class="anchor" id="section_config"></a></h3>
<p class="">The node is the peer itself. You only have to create it and it will run. </p><div class="fragment"><div class="line"><a class="code" href="classConfig.html">Config</a> config(<span class="stringliteral">&quot;configuration file path&quot;</span>, serializer, <a class="code" href="classProof.html#a457d231986439ee6bcc945daacfc28fc">Proof::WORK</a>, <a class="code" href="classHash.html#aa394d3eb7121cee0b285606664257209">Hash::HASH_MD5</a>, reward);</div></div><!-- fragment --><p> The file itself is a json file. <br />
</p>
<h6>Example:</h6>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;port&quot;: 3423,</div><div class="line">  &quot;encoding&quot;: &quot;json&quot;,</div><div class="line">  &quot;debug&quot;: true</div><div class="line">}</div></div><!-- fragment --><p> the parameters serializer, proof, hash and reward are explained later. </p><h3><a class="el" href="classTransaction.html">Transaction</a> <a class="anchor" id="section_transaction"></a></h3>
<p class="">Transactions are the most important thing to implement. <br />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;./block_chain/chain/block/transaction/Transaction.h&quot;</span></div></div><!-- fragment --><p> There is already a pure abstract class to implement, so you basicaly just have to fill the methods for your own <a class="el" href="classTransaction.html">Transaction</a> class. </p><h4>Useful methods <a class="anchor" id="sub_section_useful"></a></h4>
<h5><a class="el" href="classTransaction.html#a4cf9b81505b83a889bab80229f455589">Transaction::get_type</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> get_type() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to give a type to a transaction. Each transaction type must have a different type. It is used as an ID. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="classMoneyTransaction.html#a705918a47c0471ee7cf82bcdf0aeb5ef">MoneyTransaction::get_type</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> 2;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#a9a17c97fdcda6791484ad6d07b34470e">Transaction::operator==</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator==(<a class="code" href="classTransaction.html">Transaction</a>* t) <span class="keyword">const</span> <span class="keyword">override</span></div></div><!-- fragment --><p> This method is used to check if two transactions are the same </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator==(<a class="code" href="classTransaction.html">Transaction</a>* t)<span class="keyword"> const override </span>{</div><div class="line">    <span class="keyword">auto</span> * s = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>*<span class="keyword">&gt;</span>(t);</div><div class="line">    <span class="keywordflow">return</span> amount == s-&gt;amount &amp;&amp; target == s-&gt;target;</div><div class="line">}</div></div><!-- fragment --> <h4>Serialization methods <a class="anchor" id="sub_section_serialization"></a></h4>
<h5>Constructor</h5>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> <a class="code" href="classTransaction.html">Transaction</a>();</div></div><!-- fragment --><p> For serialization, you need an empty default constructor. </p><h5><a class="el" href="classComponent.html#a3e63d8c993e417a4af3f56d65ebfc7ea">Transaction::toElement</a></h5>
<div class="fragment"><div class="line"><a class="code" href="classElement.html">Element</a>* toElement() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to transform the object into an <a class="el" href="classElement.html">Element</a> so it can easily be serialized </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classElement.html">Element</a>* <a class="code" href="classMoneyTransaction.html#a84adc847266467965014cb04acd48bea">MoneyTransaction::toElement</a>()<span class="keyword"> const </span>{</div><div class="line">    <a class="code" href="classElementObject.html">ElementObject</a>* e = <a class="code" href="classElementCreator.html#a9ecb3456bf27d6f9b3c9f5f8130cfe63">ElementCreator::object</a>();</div><div class="line">    <span class="keywordflow">return</span> e-&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;type&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(<a class="code" href="classMoneyTransaction.html#a705918a47c0471ee7cf82bcdf0aeb5ef">get_type</a>()))</div><div class="line">            -&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;amount&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(amount))</div><div class="line">            -&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;target&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(target));</div><div class="line">}</div></div><!-- fragment --><p> The <a class="el" href="classElement.html">Element</a> system is the key for serialization. You just have to fill all of the fields and their values. If you are using many differents type of Transactions, you should use a type to help your serializer.</p>
<h5><a class="el" href="classComponent.html#a4963434fa82853534847bce22ba43a87">Transaction::fromElement</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fromElement(<a class="code" href="classElementObject.html">ElementObject</a>*, <span class="keyword">const</span> <a class="code" href="classSerializer.html">Serializer</a>*, <span class="keyword">const</span> <span class="keywordtype">char</span>* encoding) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is the opposite than toElement. It is used to build the object with a given <a class="el" href="classElement.html">Element</a> object. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a6f4672dba3a75e2782d15366d9ed7a1e">MoneyTransaction::fromElement</a>(<a class="code" href="classElementObject.html">ElementObject</a>* e, <span class="keyword">const</span> <a class="code" href="classSerializer.html">Serializer</a>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*) {</div><div class="line">    e-&gt;<a class="code" href="classElementObject.html#a7b3a1ef505e63d87ad39309c5ae1b5b3">getItem</a>(<span class="stringliteral">&quot;amount&quot;</span>, &amp;amount);</div><div class="line">    e-&gt;<a class="code" href="classElementObject.html#a7b3a1ef505e63d87ad39309c5ae1b5b3">getItem</a>(<span class="stringliteral">&quot;target&quot;</span>, &amp;target);</div><div class="line">}</div></div><!-- fragment --> <h3>UI methods <a class="anchor" id="sub_section_ui"></a></h3>
<h5><a class="el" href="classTransaction.html#ad27fb61fcd91863c57ba96a7159b4e8a">Transaction::description</a></h5>
<div class="fragment"><div class="line">std::string description() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to show the description of the transaction in the UI for the user to choose. </p><h6>Example:</h6>
<div class="fragment"><div class="line">std::string <a class="code" href="classMoneyTransaction.html#a23b793077f5c5e3157155df148e0d5e1">MoneyTransaction::description</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;give money&quot;</span>;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#a73b16e3d7e4c24e5b4da203740691e65">Transaction::fill_data</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fill_data() <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to ask the user to fill the transaction's data </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a8666737a342f5eb1856006cd970967bf">MoneyTransaction::fill_data</a>() {</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Amount of money: &quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cin &gt;&gt; amount;</div><div class="line">    }<span class="keywordflow">while</span>(amount &lt; 0);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Target key: &quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cin &gt;&gt; target;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Money transaction created&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#ad6ee9c5e4067b2f5c950c6aad131b3e4">Transaction::clone</a></h5>
<div class="fragment"><div class="line"><a class="code" href="classTransaction.html">Transaction</a>* clone() <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to create a new object of the same class. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classTransaction.html">Transaction</a>* <a class="code" href="classMoneyTransaction.html#af777b46f577df3c089a44c78c1aebc40">MoneyTransaction::clone</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>;</div><div class="line">}</div></div><!-- fragment --> <h4><a class="el" href="classDatabase.html">Database</a> methods <a class="anchor" id="sub_section_database"></a></h4>
<h5><a class="el" href="classTransaction.html#a6ea269280c8cc641878f6e5775f270ca">Transaction::apply</a></h5>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; apply(<a class="code" href="classRow.html">Row</a>* row) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to apply changes into a database. It returns a list of users to apply the reverse transaction </p><h6>Example:</h6>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; <a class="code" href="classMoneyTransaction.html#a8aa6f693c524d8e1e052b616546f9647">MoneyTransaction::apply</a>(<a class="code" href="classRow.html">Row</a>* row){</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    cr-&gt;money -= amount;</div><div class="line">    std::vector&lt;std::string&gt; targets;</div><div class="line">    targets.push_back(target);</div><div class="line">    <span class="keywordflow">return</span>  targets;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#a1ef3b245f37c217f50f8f76fceebca4a">Transaction::apply_reverse</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> apply_reverse(<a class="code" href="classRow.html">Row</a>* row) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to apply the reverse transaction changes into a database. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a9eaa71eed1cc8b06ef5773c76c814ad9">MoneyTransaction::apply_reverse</a>(<a class="code" href="classRow.html">Row</a>* row){</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    cr-&gt;money += amount;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#aa80b621537fe480dcb4444bba703abe5">Transaction::createRow</a></h5>
<div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* createRow() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> Creates a row in the database. Since Rows are custom objects from the developer, it cannot be generated by the framework, so the transactions are generating it. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* <a class="code" href="classMoneyTransaction.html#a53b636ba053baae7705976efce629d21">MoneyTransaction::createRow</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classCustomRow.html">CustomRow</a>();</div><div class="line">};</div></div><!-- fragment --> <h5><a class="el" href="classTransaction.html#a638518143f0defde1c3c73e33db1b7f1">Transaction::validate</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> validate(<a class="code" href="classRow.html">Row</a> *row) <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to check if the transaction is valid and can be add to the block chain </p><h5>Example:</h5>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMoneyTransaction.html#a20c58901a2aa8c51b73d56000545e82c">MoneyTransaction::validate</a>(<a class="code" href="classRow.html">Row</a> *row)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    <span class="keywordflow">return</span> amount &gt;= cr-&gt;money;</div><div class="line">}</div></div><!-- fragment --> <h3><a class="el" href="classReward.html">Reward</a> <a class="anchor" id="section_reward"></a></h3>
<p class="">The reward is a very particular kind of <a class="el" href="classTransaction.html">Transaction</a>. You only have to override the methods <code><a class="el" href="classTransaction.html#ad6ee9c5e4067b2f5c950c6aad131b3e4">Reward::clone</a></code> and <code><a class="el" href="classTransaction.html#aa80b621537fe480dcb4444bba703abe5">Reward::createRow</a></code>. </p><h3><a class="el" href="classProof.html">Proof</a> <a class="anchor" id="section_proof"></a></h3>
<p class="">Proofs are the basis of block chain validation. Some proofs are implemented, but not all of them. Therefore, you can create your own proof and send it to the framework. </p><h4>New proof <a class="anchor" id="sub_section_newproof"></a></h4>
<p class="">A new proof class needs to implements 2 methods </p><h5><a class="el" href="classProof.html#a6ab9f6c3f603447e3a9c7c932b5deac4">Proof::run</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> run(<a class="code" href="classBlock.html">Block</a>* block, std::string key) = 0;</div></div><!-- fragment --><p> This method will be called to generate the proof, and it will create a new <a class="el" href="classMetadata.html">Metadata</a> for the current block. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classProofOfWork.html#a31d9107577bafc58c5ce2374e79f2b3c">ProofOfWork::run</a>(<a class="code" href="classBlock.html">Block</a>* block, std::string key){</div><div class="line">    <a class="code" href="classHash.html">Hash</a> tmp((block-&gt;parent_fingerprint != <span class="keyword">nullptr</span> ? block-&gt;parent_fingerprint-&gt;to_string() : <span class="stringliteral">&quot;0&quot;</span>) + key);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> i = 1; i &gt; 0 ; i++){</div><div class="line">        <a class="code" href="classHash.html">Hash</a> t(&amp;tmp, i);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> j = 1; j &gt; 0 ; j++) {</div><div class="line">            <a class="code" href="classHash.html">Hash</a> h(&amp;t, j);</div><div class="line">            <span class="keywordflow">if</span>(h.to_string().substr(0, 1) == <span class="stringliteral">&quot;0&quot;</span>){</div><div class="line">                block-&gt;data = <span class="keyword">new</span> <a class="code" href="classProofOfWorkMetadata.html">ProofOfWorkMetadata</a>(i, j, key);</div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classProof.html#afbe82d6d8c190929239b8862343ab396">Proof::accept</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> accept(<a class="code" href="classBlock.html">Block</a>* block, <a class="code" href="classMessage.html">Message</a>*) = 0;</div></div><!-- fragment --><p> This method will be called to check is the metadata generated by the method run by another peer is correct. <br />
 If it is not correct, it means the peer is generating false data, therefore the block must be rejected </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classProofOfWork.html#aa414484a6dc03fec583996a591f36856">ProofOfWork::accept</a>(<a class="code" href="classBlock.html">Block</a>* block, <a class="code" href="classMessage.html">Message</a>* m){</div><div class="line">    <span class="keyword">auto</span> data = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classProofOfWorkMetadata.html">ProofOfWorkMetadata</a>*<span class="keyword">&gt;</span>(block-&gt;data);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> tmp((block-&gt;parent_fingerprint != <span class="keyword">nullptr</span> ? block-&gt;parent_fingerprint-&gt;to_string() : <span class="stringliteral">&quot;0&quot;</span>) + data-&gt;winner);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> t(&amp;tmp, data-&gt;first);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> h(&amp;t, data-&gt;second);</div><div class="line">    <span class="keywordflow">return</span> h.to_string().substr(0, 1) == <span class="stringliteral">&quot;0&quot;</span>;</div><div class="line">}</div></div><!-- fragment --> <h4>Feed the framework <a class="anchor" id="sub_section_feedframework"></a></h4>
<p class="">Once your proof is done, you just have to give it to the framework using this method: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classProof.html#a71874539fdbcc93c15594b889c95225b">Proof::add_proof</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::function&lt;<a class="code" href="classProof.html">Proof</a>*()&gt; proof);</div></div><!-- fragment --><p> The id needs to be passed to the <a class="el" href="classNode.html">Node</a> object. The second parameter is a lambda expression that creates the proof. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classProof.html#a71874539fdbcc93c15594b889c95225b">Proof::add_proof</a>(<a class="code" href="classProof.html#a457d231986439ee6bcc945daacfc28fc">Proof::WORK</a>, []() -&gt; <a class="code" href="classProof.html">Proof</a>*{<span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classProofOfWork.html">ProofOfWork</a>;});</div></div><!-- fragment --> <h4>New metadata <a class="anchor" id="sub_section_newmetadata"></a></h4>
<p class="">If your proof require a new metadata class, you just have to provide this metadata to the serializer using this method. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> add_metadata(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::function&lt;<a class="code" href="classMetadata.html">Metadata</a>*()&gt; metadata);</div></div><!-- fragment --> <h6>Example:</h6>
<div class="fragment"><div class="line">serial-&gt;add_metadata(CustomMetadata::TYPE, []() -&gt; <a class="code" href="classMetadata.html">Metadata</a>*{<span class="keywordflow">return</span> <span class="keyword">new</span> CustomMetadata;});</div></div><!-- fragment --> <h3><a class="el" href="classHash.html">Hash</a> <a class="anchor" id="section_hash"></a></h3>
<p class=""><a class="el" href="classHash.html">Hash</a> are the results of hashing function. There are some implemented hashing functions and you can create your own. </p><h4>New <a class="el" href="classHash.html">Hash</a> <a class="anchor" id="sub_section_newhash"></a></h4>
<p class="">A new hash class needs to implements 6 methods, but this method is always the same, with different parameters type </p><h5><a class="el" href="classHash.html#abc9d5b49c4098928379cac62d9242a54">Hash::generate_hash</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> std::string generate_hash(std::string hash1, <span class="keywordtype">double</span> value) = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> std::string generate_hash(std::string hash1, <span class="keywordtype">int</span> value) = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> std::string generate_hash(std::string hash1, <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> value) = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> std::string generate_hash(std::string hash1, std::string value) = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> std::string generate_hash(std::string value) = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> std::string generate_hash(<span class="keyword">const</span> <a class="code" href="classComponent.html">Component</a>* component, <span class="keyword">const</span> <a class="code" href="classSerializer.html">Serializer</a>* serializer, <span class="keyword">const</span> <span class="keywordtype">char</span>* encoding) = 0;</div></div><!-- fragment --><p> This method will be called to generate the hash according to the algorithm you chose. </p><h6>Example:</h6>
<div class="fragment"><div class="line">std::string <a class="code" href="classHash__MD5.html#a979e64b139fc15d07563d9fac3d9260d">Hash_MD5::generate_hash</a>(std::string hash1, std::string value){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> digest[MD5_DIGEST_LENGTH + 1];</div><div class="line">    std::string str = hash1 + value;</div><div class="line">    MD5((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) str.c_str(), str.size(), digest);</div><div class="line">    digest[MD5_DIGEST_LENGTH] = 0;</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classEncoding.html#afa3343b66a1a0598b2dc01d74cb81861">Encoding::toHexa</a>(std::string((<span class="keyword">const</span> <span class="keywordtype">char</span>*)digest));</div><div class="line">}</div></div><!-- fragment --> <h4>Feed the framework <a class="anchor" id="sub_section_feedframeworkhash"></a></h4>
<p class="">Once your hash is done, you just have to give it to the framework using this method: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classHash.html#a0ef31c937ec2ff1c73c800cc0e4ddf5d">Hash::add_hash</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::function&lt;<a class="code" href="classHash.html">Hash</a>*()&gt; h);</div></div><!-- fragment --><p> The id needs to be passed to the <a class="el" href="classNode.html">Node</a> object. The second parameter is a lambda expression that creates the hash. </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classHash.html#a0ef31c937ec2ff1c73c800cc0e4ddf5d">Hash::add_hash</a>(<a class="code" href="classHash.html#aa394d3eb7121cee0b285606664257209">Hash::HASH_MD5</a>, []() -&gt; <a class="code" href="classHash.html">Hash</a>*{<span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classHash__MD5.html">Hash_MD5</a>;});</div></div><!-- fragment --> <h3><a class="el" href="classDatabase.html">Database</a> <a class="anchor" id="section_database"></a></h3>
<p class="">The database is basically a map of <a class="el" href="classRow.html">Row</a>. Rows are pure abstract classes that needs to be implemented, because their structure depends of your implementation <br />
 There are 3 methods that must be implemented. </p><h5><a class="el" href="classRow.html#ae3e9c3aaa17ebc4f0e280cdec722440a">Row::clone</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classRow.html">Row</a>* clone() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p> Like Transactions, you need to duplicate the <a class="el" href="classRow.html">Row</a> in order to accept differents states on differents blocks in the block chain </p><h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* <a class="code" href="classCustomRow.html#a9d3c1b6bda5e63de382cc4a2aa29210d">CustomRow::clone</a>()<span class="keyword"> const</span>{</div><div class="line">    <span class="keyword">auto</span> r = <span class="keyword">new</span> <a class="code" href="classCustomRow.html">CustomRow</a>;</div><div class="line">    r-&gt;money = money;</div><div class="line">    r-&gt;status = status;</div><div class="line">    r-&gt;messages = messages;</div><div class="line">    <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classRow.html#ae7b1aba7a4c868914700432850c2848d">Row::to_string</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> std::string to_string() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p> Like Transactions, you need a visual representation of the database </p><h6>Example:</h6>
<div class="fragment"><div class="line">std::string <a class="code" href="classCustomRow.html#ae1e5a3b861829f8b295d3c743d6b3c7a">CustomRow::to_string</a>()<span class="keyword"> const </span>{</div><div class="line">    std::string str;</div><div class="line">    str += <span class="stringliteral">&quot;[&quot;</span> + status + <span class="stringliteral">&quot;] (value: &quot;</span> + std::to_string(money) + <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a : messages)</div><div class="line">        str += <span class="stringliteral">&quot; - &quot;</span> + a + <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> str;</div><div class="line">}</div></div><!-- fragment --> <h5><a class="el" href="classRow.html#a851b728fa55ecb26f8ebbc87e614581b">Row::reward</a></h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> reward() = 0;</div></div><!-- fragment --><p> The reward method is called to reward the user who validated the block </p><h6>Example:</h6>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classCustomRow.html#a007002dc965ca2727ec8db0183404bf1">CustomRow::reward</a>() {</div><div class="line">    money += 1;</div><div class="line">}</div></div><!-- fragment --> <h2>Helpers <a class="anchor" id="section_helpers"></a></h2>
<h3><a class="el" href="classTransactionManager.html">TransactionManager</a> <a class="anchor" id="section_transactionManager"></a></h3>
<p class="">The transaction manager is a built in class from the framework. You only need to give it a list of transactions, and then to give it to the <a class="el" href="classNode.html">Node</a> object. </p><div class="fragment"><div class="line"><a class="code" href="classTransactionManager.html">TransactionManager</a> manager;</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classStatusTransaction.html">StatusTransaction</a>);</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>);</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classMessagesTransaction.html">MessagesTransaction</a>);</div><div class="line">node.start(manager);</div></div><!-- fragment --><p> The provided <a class="el" href="classTransactionManager.html">TransactionManager</a> class allows you to easily run every type of transactions without implementing anything. <br />
 However, this class is a helper, you can easily manage the transactions creation by yourself without this class. <br />
 If you choose this solution, you only have to use the <a class="el" href="classNode.html#a3a3c8197be701cb23a3c9b2a2c981e94">Node::request_transaction</a> method in order to process your transactions.<br />
 It can also be replaced by the <a href="#section_framework">Framework helper</a>. </p><h3><a class="el" href="classSerializer.html">Serializer</a> <a class="anchor" id="section_serializer"></a></h3>
<p class="">The serialization class is used to transform Objects into string using Elements and strings into Objects using Elements. To use this class, you need to register your own transactions with a lambda expression </p><h5><a class="el" href="classSerializer.html#ab5fa979a8486be6f49ad10f4810509d7">Serializer::unserializeTransaction</a></h5>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add_transaction(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::function&lt;<a class="code" href="classTransaction.html">Transaction</a>*()&gt; transaction);</div></div><!-- fragment --> <h6>Example:</h6>
<div class="fragment"><div class="line">serial-&gt;add_transaction(money-&gt;get_type(), []() -&gt; <a class="code" href="classTransaction.html">Transaction</a>*{<span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>;});</div></div><!-- fragment --><p> It can also be replaced by the <a href="#section_framework">Framework helper</a>. </p><h3><a class="el" href="classFramework.html">Framework</a> <a class="anchor" id="section_framework"></a></h3>
<p class="">In order to make the creation of the different tools easier, the framework provides an important (but not required) helper class, <a class="el" href="classFramework.html">Framework</a>. <br />
 This class only needs a list of <a class="el" href="classTransaction.html">Transaction</a> as input and generates both <a class="el" href="classTransactionManager.html">TransactionManager</a> and <a class="el" href="classSerializer.html">Serializer</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classFramework.html#ad6ef9b255453a080747e1a018f87eaa0">Framework::add_transaction</a>(<a class="code" href="classTransaction.html">Transaction</a>* transaction);</div></div><!-- fragment --> <h6>Example:</h6>
<div class="fragment"><div class="line"><a class="code" href="classFramework.html">Framework</a> block_chain;</div><div class="line">block_chain.<a class="code" href="classFramework.html#ad6ef9b255453a080747e1a018f87eaa0">add_transaction</a>(<span class="keyword">new</span> <a class="code" href="classStatusTransaction.html">StatusTransaction</a>);</div><div class="line">block_chain.<a class="code" href="classFramework.html#ad6ef9b255453a080747e1a018f87eaa0">add_transaction</a>(<span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>);</div><div class="line">block_chain.<a class="code" href="classFramework.html#ad6ef9b255453a080747e1a018f87eaa0">add_transaction</a>(<span class="keyword">new</span> <a class="code" href="classMessagesTransaction.html">MessagesTransaction</a>);</div><div class="line"></div><div class="line"><span class="comment">//Get the manager</span></div><div class="line"><span class="keyword">auto</span> manager = block_chain.<a class="code" href="classFramework.html#ac40d7e3f2510b3a8fcb2fdece53e2677">generate_manager</a>();</div><div class="line"></div><div class="line"><span class="comment">//Get the serializer</span></div><div class="line"><span class="keyword">auto</span> serial = block_chain.<a class="code" href="classFramework.html#a6f09bafd5ac80cddbd89829924972127">generate_serializer</a>();</div></div><!-- fragment --> <h2>TODO-List <a class="anchor" id="section_todo"></a></h2>
<h3>Cryptography <a class="anchor" id="sub_section_cryptography"></a></h3>
<p class="">For now, there is only one cryptography class based on RSA. <br />
 It will be changed to make this cryptography class abstract with the possibility for the user to create his own cryptography class (And to keep some basic cryptography functions).</p>
<h3><a class="el" href="classProof.html">Proof</a> <a class="anchor" id="sub_section_proof"></a></h3>
<p class="">For now, there is only one proof: the proof of work. <br />
 The framework will be updated with new proofs</p>
<h3>Header files <a class="anchor" id="sub_section_header"></a></h3>
<p class="">For now, the installation of the framework is simple by copying files.<br />
 A complete version of the program will run with header files and DLL files. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
