<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Block-chain framework: Block-chain Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block-chain framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Block-chain Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview</h2>
<p class="">This project is a C++ Framework built to allow easy and fast development of any kind of block-chain. \ The idea is to limit the development to transactions and data representation only. No need to implement anything else. \ Of course, as a framework, it needs a big flexibility, therefore, it is possible to write much more advanced block-chain by configuring as many things as you want. \ </p><blockquote class="doxtable">
<p class="">Note that everything can change to allow more flexibility. </p>
</blockquote>
<h2><a class="el" href="classNode.html">Node</a></h2>
<p class="">The node is the peer itself. You only have to create it and it will run. </p><div class="fragment"><div class="line"><a class="code" href="classNode.html">Node</a> node(config);</div></div><!-- fragment --> <h2><a class="el" href="classConfig.html">Config</a></h2>
<p class="">The node is the peer itself. You only have to create it and it will run. </p><div class="fragment"><div class="line"><a class="code" href="classConfig.html">Config</a> config(<span class="stringliteral">&quot;configuration file path&quot;</span>, serializer, <a class="code" href="classProof.html#a457d231986439ee6bcc945daacfc28fc">Proof::WORK</a>, reward);</div></div><!-- fragment --><p> The file itself is a json file. ##### Example: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;port&quot;: 3423,</div><div class="line">  &quot;encoding&quot;: &quot;json&quot;,</div><div class="line">  &quot;debug&quot;: true</div><div class="line">}</div></div><!-- fragment --><p> the parameters serializer, proof and reward are explained later. </p><h2><a class="el" href="classTransaction.html">Transaction</a></h2>
<p class="">Transactions are the most important thing to implement. \ </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;./block_chain/chain/block/transaction/Transaction.h&quot;</span></div></div><!-- fragment --><p> There is already a pure abstract class to implement, so you basicaly just have to fill the methods for your own <a class="el" href="classTransaction.html">Transaction</a> class. </p><h3>Useful methods</h3>
<p class="">#### get_type </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> get_type() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to give a type to a transaction. Each transaction type must have a different type. It is used as an ID. ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="classMoneyTransaction.html#a705918a47c0471ee7cf82bcdf0aeb5ef">MoneyTransaction::get_type</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> 2;</div><div class="line">}</div></div><!-- fragment --><p> #### == </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator==(<a class="code" href="classTransaction.html">Transaction</a>* t) <span class="keyword">const</span> <span class="keyword">override</span></div></div><!-- fragment --><p> This method is used to check if two transactions are the same ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator==(<a class="code" href="classTransaction.html">Transaction</a>* t)<span class="keyword"> const override </span>{</div><div class="line">    <span class="keyword">auto</span> * s = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>*<span class="keyword">&gt;</span>(t);</div><div class="line">    <span class="keywordflow">return</span> amount == s-&gt;amount &amp;&amp; target == s-&gt;target;</div><div class="line">}</div></div><!-- fragment --> <h3>Serialization methods</h3>
<p class="">#### Constructor </p><div class="fragment"><div class="line"><span class="keyword">explicit</span> <a class="code" href="classTransaction.html">Transaction</a>();</div></div><!-- fragment --><p> For serialization, you need an empty default constructor. #### toElement </p><div class="fragment"><div class="line"><a class="code" href="classElement.html">Element</a>* toElement() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to transform the object into an <a class="el" href="classElement.html">Element</a> so it can easily be serialized ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classElement.html">Element</a>* <a class="code" href="classMoneyTransaction.html#a84adc847266467965014cb04acd48bea">MoneyTransaction::toElement</a>()<span class="keyword"> const </span>{</div><div class="line">    <a class="code" href="classElementObject.html">ElementObject</a>* e = <a class="code" href="classElementCreator.html#a9ecb3456bf27d6f9b3c9f5f8130cfe63">ElementCreator::object</a>();</div><div class="line">    <span class="keywordflow">return</span> e-&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;type&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(<a class="code" href="classMoneyTransaction.html#a705918a47c0471ee7cf82bcdf0aeb5ef">get_type</a>()))</div><div class="line">            -&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;amount&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(amount))</div><div class="line">            -&gt;<a class="code" href="classElementObject.html#ab9dd82037b752ab2e6f4e3de53348483">put</a>(<span class="stringliteral">&quot;target&quot;</span>, <a class="code" href="classElementCreator.html#a4d2ee7d169ec568eb76e41dc0baaf314">ElementCreator::create</a>(target));</div><div class="line">}</div></div><!-- fragment --><p> The <a class="el" href="classElement.html">Element</a> system is the key for serialization. You just have to fill all of the fields and their values. If you are using many differents type of Transactions, you should use a type to help your serializer.</p>
<p class="">#### fromElement (protected) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> fromElement(<a class="code" href="classElementObject.html">ElementObject</a>*, <span class="keyword">const</span> <a class="code" href="classSerializer.html">Serializer</a>*, <span class="keyword">const</span> <span class="keywordtype">char</span>* encoding) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is the opposite than toElement. It is used to build the object with a given <a class="el" href="classElement.html">Element</a> object. ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a6f4672dba3a75e2782d15366d9ed7a1e">MoneyTransaction::fromElement</a>(<a class="code" href="classElementObject.html">ElementObject</a>* e, <span class="keyword">const</span> <a class="code" href="classSerializer.html">Serializer</a>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*) {</div><div class="line">    e-&gt;<a class="code" href="classElementObject.html#a7b3a1ef505e63d87ad39309c5ae1b5b3">getItem</a>(<span class="stringliteral">&quot;amount&quot;</span>, &amp;amount);</div><div class="line">    e-&gt;<a class="code" href="classElementObject.html#a7b3a1ef505e63d87ad39309c5ae1b5b3">getItem</a>(<span class="stringliteral">&quot;target&quot;</span>, &amp;target);</div><div class="line">}</div></div><!-- fragment --> <h3>UI methods</h3>
<p class="">#### description </p><div class="fragment"><div class="line">std::string description() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to show the description of the transaction in the UI for the user to choose. ##### Example: </p><div class="fragment"><div class="line">std::string <a class="code" href="classMoneyTransaction.html#a23b793077f5c5e3157155df148e0d5e1">MoneyTransaction::description</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;give money&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p> #### fill_data </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> fill_data() <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to ask the user to fill the transaction's data ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a8666737a342f5eb1856006cd970967bf">MoneyTransaction::fill_data</a>() {</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Amount of money: &quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cin &gt;&gt; amount;</div><div class="line">    }<span class="keywordflow">while</span>(amount &lt; 0);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Target key: &quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cin &gt;&gt; target;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Money transaction created&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> #### clone </p><div class="fragment"><div class="line"><a class="code" href="classTransaction.html">Transaction</a>* clone() <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to create a new object of the same class. ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classTransaction.html">Transaction</a>* <a class="code" href="classMoneyTransaction.html#af777b46f577df3c089a44c78c1aebc40">MoneyTransaction::clone</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>;</div><div class="line">}</div></div><!-- fragment --> <h3><a class="el" href="classDatabase.html">Database</a> methods</h3>
<p class="">#### apply </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; apply(<a class="code" href="classRow.html">Row</a>* row) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to apply changes into a database. It returns a list of users to apply the reverse transaction ##### Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; <a class="code" href="classMoneyTransaction.html#a8aa6f693c524d8e1e052b616546f9647">MoneyTransaction::apply</a>(<a class="code" href="classRow.html">Row</a>* row){</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    cr-&gt;money -= amount;</div><div class="line">    std::vector&lt;std::string&gt; targets;</div><div class="line">    targets.push_back(target);</div><div class="line">    <span class="keywordflow">return</span>  targets;</div><div class="line">}</div></div><!-- fragment --><p> #### apply_reverse </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> apply_reverse(<a class="code" href="classRow.html">Row</a>* row) <span class="keyword">override</span>;</div></div><!-- fragment --><p> This method is used to apply the reverse transaction changes into a database. ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMoneyTransaction.html#a9eaa71eed1cc8b06ef5773c76c814ad9">MoneyTransaction::apply_reverse</a>(<a class="code" href="classRow.html">Row</a>* row){</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    cr-&gt;money += amount;</div><div class="line">}</div></div><!-- fragment --><p> #### createRow </p><div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* createRow() <span class="keyword">const override</span>;</div></div><!-- fragment --><p> Creates a row in the database. Since Rows are custom objects from the developper, it cannot be generated by the framework, so the transactions are generating it. ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* <a class="code" href="classMoneyTransaction.html#a53b636ba053baae7705976efce629d21">MoneyTransaction::createRow</a>()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classCustomRow.html">CustomRow</a>();</div><div class="line">};</div></div><!-- fragment --><p> #### validate </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> validate(<a class="code" href="classRow.html">Row</a> *row) <span class="keyword">const override</span>;</div></div><!-- fragment --><p> This method is used to check if the transaction is valid and can be add to the block chain ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMoneyTransaction.html#a20c58901a2aa8c51b73d56000545e82c">MoneyTransaction::validate</a>(<a class="code" href="classRow.html">Row</a> *row)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">auto</span> * cr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classCustomRow.html">CustomRow</a>*<span class="keyword">&gt;</span>(row);</div><div class="line">    <span class="keywordflow">return</span> amount &gt;= cr-&gt;money;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="el" href="classReward.html">Reward</a></h2>
<p class="">The reward is a very particular kind of <a class="el" href="classTransaction.html">Transaction</a>. You only have to override the methods <code>clone</code> and <code>createRow</code>. </p><h2><a class="el" href="classTransactionManager.html">TransactionManager</a></h2>
<p class="">The transaction manager is a built in class from the framework. You only need to give it a list of transactions, and then to give it to the <a class="el" href="classNode.html">Node</a> object. </p><div class="fragment"><div class="line"><a class="code" href="classTransactionManager.html">TransactionManager</a> manager;</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classStatusTransaction.html">StatusTransaction</a>);</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classMoneyTransaction.html">MoneyTransaction</a>);</div><div class="line">manager.<a class="code" href="classTransactionManager.html#a7956f511249bba3466ce3f3b57ee4518">put</a>(<span class="keyword">new</span> <a class="code" href="classMessagesTransaction.html">MessagesTransaction</a>);</div><div class="line">node.start(manager);</div></div><!-- fragment --> <h2><a class="el" href="classSerializer.html">Serializer</a></h2>
<p class="">The serialization class is used to transfrom Objects into string using Elements and strings into Objects using Elements. One method from this class needs to be overridden: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTransaction.html">Transaction</a>* unserializeTransaction(std::string transaction, <span class="keyword">const</span> <span class="keywordtype">char</span>* encoding) <span class="keyword">const</span>;</div></div><!-- fragment --><p> It need to be overridden because the framework doesn't know about your transactions, therefore, you have to implement this method using the <a class="el" href="classSerializer.html">Serializer</a> methods ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classTransaction.html">Transaction</a>* <a class="code" href="classCustomSerializer.html#abff58f1a955c2f399127b7e3cae23223">CustomSerializer::unserializeTransaction</a>(std::string transaction, <span class="keyword">const</span> <span class="keywordtype">char</span>* key)<span class="keyword"> const </span>{</div><div class="line">    <a class="code" href="classElementObject.html">ElementObject</a>* e = <a class="code" href="classSerializer.html#ab3bcdbd49167109de13e03878337018a">getElement</a>(transaction, key);</div><div class="line">    <span class="keywordtype">int</span> type;</div><div class="line">    e-&gt;<a class="code" href="classElementObject.html#a7b3a1ef505e63d87ad39309c5ae1b5b3">getItem</a>(<span class="stringliteral">&quot;type&quot;</span>, &amp;type);</div><div class="line">    <a class="code" href="classTransaction.html">Transaction</a>* t;</div><div class="line">    <span class="keywordflow">if</span>(!type)</div><div class="line">        t = <span class="keyword">new</span> <a class="code" href="classStatusTransaction.html">StatusTransaction</a>();</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        t = <span class="keyword">new</span> <a class="code" href="classMessagesTransaction.html">MessagesTransaction</a>();</div><div class="line">    t-&gt;<a class="code" href="classComponent.html#a28212595f8ee85fe009bd233bc99b2fc">__init__</a>(e, <span class="keyword">this</span>, key);</div><div class="line">    <span class="keywordflow">return</span> t;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="el" href="classProof.html">Proof</a></h2>
<p class="">Proofs are ## run the basis of block chain validation. Some proofs are implemented, but not all of them. Therefore, you can create your own proof and send it to the framework. </p><h3>New proof</h3>
<p class="">A new proof class needs to implements 2 methods #### run </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> run(<a class="code" href="classBlock.html">Block</a>* block, std::string key) = 0;</div></div><!-- fragment --><p> This method will be called to generate the proof, and it will create a new <a class="el" href="classMetadata.html">Metadata</a> for the current block. ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classProofOfWork.html#a31d9107577bafc58c5ce2374e79f2b3c">ProofOfWork::run</a>(<a class="code" href="classBlock.html">Block</a>* block, std::string key){</div><div class="line">    <a class="code" href="classHash.html">Hash</a> tmp((block-&gt;parent_fingerprint != <span class="keyword">nullptr</span> ? block-&gt;parent_fingerprint-&gt;<a class="code" href="classHash.html#ab1c275871d3d81cd38d58dac5c634042">to_string</a>() : <span class="stringliteral">&quot;0&quot;</span>) + key);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> i = 1; i &gt; 0 ; i++){</div><div class="line">        <a class="code" href="classHash.html">Hash</a> t(&amp;tmp, i);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> j = 1; j &gt; 0 ; j++) {</div><div class="line">            <a class="code" href="classHash.html">Hash</a> h(&amp;t, j);</div><div class="line">            <span class="keywordflow">if</span>(h.to_string().substr(0, 1) == <span class="stringliteral">&quot;0&quot;</span>){</div><div class="line">                block-&gt;data = <span class="keyword">new</span> <a class="code" href="classProofOfWorkMetadata.html">ProofOfWorkMetadata</a>(i, j, key);</div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> #### accept </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> accept(<a class="code" href="classBlock.html">Block</a>* block, <a class="code" href="classMessage.html">Message</a>*) = 0;</div></div><!-- fragment --><p> This method will be called to check is the metadata generated by the method run by another peer is correct. \ If it is not correct, it means the peer is generating false data, therefore the block must be rejected ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classProofOfWork.html#aa414484a6dc03fec583996a591f36856">ProofOfWork::accept</a>(<a class="code" href="classBlock.html">Block</a>* block, <a class="code" href="classMessage.html">Message</a>* m){</div><div class="line">    <span class="keyword">auto</span> data = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classProofOfWorkMetadata.html">ProofOfWorkMetadata</a>*<span class="keyword">&gt;</span>(block-&gt;data);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> tmp((block-&gt;parent_fingerprint != <span class="keyword">nullptr</span> ? block-&gt;parent_fingerprint-&gt;<a class="code" href="classHash.html#ab1c275871d3d81cd38d58dac5c634042">to_string</a>() : <span class="stringliteral">&quot;0&quot;</span>) + data-&gt;winner);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> t(&amp;tmp, data-&gt;first);</div><div class="line">    <a class="code" href="classHash.html">Hash</a> h(&amp;t, data-&gt;second);</div><div class="line">    <span class="keywordflow">return</span> h.to_string().substr(0, 1) == <span class="stringliteral">&quot;0&quot;</span>;</div><div class="line">}</div></div><!-- fragment --> <h3>Give the proof to the framework</h3>
<p class="">One your proof is done, you just have to give it to the framework using this method: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classProof.html#a71874539fdbcc93c15594b889c95225b">Proof::add_proof</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::function&lt;<a class="code" href="classProof.html">Proof</a>*()&gt; proof);</div></div><!-- fragment --><p> The id needs to be passed to the <a class="el" href="classNode.html">Node</a> object. The second parameter is a lambda that creates the proof. ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classProof.html#a71874539fdbcc93c15594b889c95225b">Proof::add_proof</a>(<a class="code" href="classProof.html#a457d231986439ee6bcc945daacfc28fc">Proof::WORK</a>, []() -&gt; <a class="code" href="classProof.html">Proof</a>*{<span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classProofOfWork.html">ProofOfWork</a>;});</div></div><!-- fragment --> <h2><a class="el" href="classDatabase.html">Database</a></h2>
<p class="">The database is basically a map of <a class="el" href="classRow.html">Row</a>. Rows are pure abstract classes that needs to be implemented, because their structure depends of your implementation \ There are 3 methods that must be implemented. #### clone </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classRow.html">Row</a>* clone() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p> Like Transactions, you need to duplicate the <a class="el" href="classRow.html">Row</a> in order to accept differents states on differents blocks in the block chain ##### Example: </p><div class="fragment"><div class="line"><a class="code" href="classRow.html">Row</a>* <a class="code" href="classCustomRow.html#a9d3c1b6bda5e63de382cc4a2aa29210d">CustomRow::clone</a>()<span class="keyword"> const</span>{</div><div class="line">    <span class="keyword">auto</span> r = <span class="keyword">new</span> <a class="code" href="classCustomRow.html">CustomRow</a>;</div><div class="line">    r-&gt;money = money;</div><div class="line">    r-&gt;status = status;</div><div class="line">    r-&gt;messages = messages;</div><div class="line">    <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --><p> #### to_string </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> std::string to_string() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p> Like Transactions, you need a visual representation of the database ##### Example: </p><div class="fragment"><div class="line">std::string <a class="code" href="classCustomRow.html#ae1e5a3b861829f8b295d3c743d6b3c7a">CustomRow::to_string</a>()<span class="keyword"> const </span>{</div><div class="line">    std::string str;</div><div class="line">    str += <span class="stringliteral">&quot;[&quot;</span> + status + <span class="stringliteral">&quot;] (value: &quot;</span> + std::to_string(money) + <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a : messages)</div><div class="line">        str += <span class="stringliteral">&quot; - &quot;</span> + a + <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> str;</div><div class="line">}</div></div><!-- fragment --><p> #### reward </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> reward() = 0;</div></div><!-- fragment --><p> The reward method is called to reward the user who validated the block ##### Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classCustomRow.html#a007002dc965ca2727ec8db0183404bf1">CustomRow::reward</a>() {</div><div class="line">    money += 1;</div><div class="line">}</div></div><!-- fragment --> <h2>TODO-List</h2>
<h3><a class="el" href="classHash.html">Hash</a></h3>
<p class="">For now, there is only one hash class based on md5. \ It will be changed to make this hash class abstract with the possibility for the user to create his own hash class (And to keep some basic hash functions).</p>
<h3>Cryptography</h3>
<p class="">For now, there is only one cryptography class based on RSA. \ It will be changed to make this cryptography class abstract with the possibility for the user to create his own cryptography class (And to keep some basic cryptography functions).</p>
<h3>Proofs</h3>
<p class="">For now, there is only one proof: the proof of work. \ The framework will be updated with new proofs </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
